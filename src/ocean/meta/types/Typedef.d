/*******************************************************************************

    Copyright:
        Copyright (C) 2017 dunnhumby Germany GmbH. All rights reserved.

    NB: because this module is often used as purely compile-time dependency it
        used built-in asserts instead of `ocean.core.Test` to reduce amount of
        cyclic imports. `ocean.meta` modules in general are not supposed to
        import anything outside of `ocean.meta`.

    License:
        Boost Software License Version 1.0. See LICENSE_BOOST.txt for details.
        Alternatively, this file may be distributed under the terms of the Tango
        3-Clause BSD License (see LICENSE_BSD.txt for details).

*******************************************************************************/

module ocean.meta.types.Typedef;

import ocean.meta.types.Qualifiers;

/*******************************************************************************

    Replacement for `typedef` which is completely deprecated.

    It generates a wrapper struct with `alias this`.

    Used as mixin(Typedef!(hash_t, "MyHash"))

    `IsTypedef` member alias is defined so that any struct type can be quickly
    checked if it originates from typedef via `is(typeof(S.IsTypedef))`.
    This is a hack reserved for backwards compatibility in libraries and should
    never be relied upon in user code.

    Parameters:
        T       = type to typedef
        name    = identifier string for new type
        initval = optional default value for that type

*******************************************************************************/

template Typedef(T, istring name, T initval)
{
    static assert (name.length, "Can't create Typedef with an empty identifier");

    enum Typedef =
        ("static struct " ~ name ~
        "{ " ~
        "alias IsTypedef = void;" ~
        T.stringof ~ " value = " ~ initval.stringof ~ ";" ~
        "alias value this;" ~
        "this(" ~ T.stringof ~ " rhs) { this.value = rhs; }" ~
        " }");
}

/// ditto
template Typedef(T, istring name)
{
    static assert (name.length, "Can't create Typedef with an empty identifier");

    enum Typedef =
        ("static struct " ~ name ~
        "{ " ~
        "alias IsTypedef = void;" ~
        T.stringof ~ " value; " ~
        "alias value this;" ~
        "this(" ~ T.stringof ~ " rhs) { this.value = rhs; }" ~
        " }");
}

unittest
{
    mixin(Typedef!(int, "MyInt1", 42));
    mixin(Typedef!(int, "MyInt2", 42));

    static assert (!is(MyInt1 : MyInt2));

    MyInt1 myint;
    assert(myint == 42);

    void foo1(MyInt2) { }
    void foo2(MyInt1) { }
    void foo3(int) { }

    static assert (!is(typeof(foo1(myint))));
    static assert ( is(typeof(foo2(myint))));
    static assert ( is(typeof(foo3(myint))));

    int base = myint;
    assert(base == myint);
    myint = cast(MyInt1) (base + 1);
    assert(myint == 43);
}

unittest
{
    struct MyType { }

    mixin(Typedef!(MyType, "MyType2"));
    MyType2 var;

    static assert (is(typeof(var) : MyType));
}

unittest
{
    mixin(Typedef!(int, "MyInt"));
    MyInt var = 42;
    assert (var == 42);
}

/*******************************************************************************

    Resolves to type used as first argument to `Typedef!(type, name)` call
    when defining T.

    Params:
        T = type to reduce to base, must be generated by `Typedef`

*******************************************************************************/

template TypedefBaseType ( T )
{
    alias typeof(T.value) TypedefBaseType;
}

unittest
{
    mixin(Typedef!(int, "MyInt"));
    static assert (is(TypedefBaseType!(MyInt) == int));
}

/*******************************************************************************

    Helper function to reduce typedef to its base value

    Params:
        T = type to reduce to base, must be generated by `Typedef`

    Returns:
        `value` cast to `TypedefBaseType!(T)`

*******************************************************************************/

TypedefBaseType!(T) castToBase ( T ) ( T value )
{
    return cast(TypedefBaseType!(T)) value;
}

unittest
{
    mixin(Typedef!(int, "MyInt"));
    MyInt value = 42;
    assert (castToBase(value) == 42);
    static assert (is(typeof(castToBase(value)) == int));
}
